\hypertarget{md_note_autotoc_md2}{}\doxysection{函数设计：}\label{md_note_autotoc_md2}
{\bfseries{sync\+\_\+uma}} 一个后台线程用于sync。在nvmmap时创建。定期执行sync\+\_\+uma

{\bfseries{nvmsync(void $\ast$addr, size\+\_\+t len, int flags)}} 将内存映射文件写回
\begin{DoxyEnumerate}
\item 根据addr查找uma。（先cache在rbtree）
\item nvmsync\+\_\+uma持久化uma。
\end{DoxyEnumerate}

{\bfseries{nvmsync\+\_\+uma(void $\ast$addr, size\+\_\+t len, int flags, uma\+\_\+t $\ast$uma)$\ast$$\ast$持久化uma，并调用nvmsync\+\_\+sync持久化文件
\begin{DoxyEnumerate}
\item 对uma上锁。
\item 全局epoch加1
\item flush uma. $\ast$$\ast$nvmmio\+\_\+flush
\item 更新log policy，如果策略不变则直接返回
\item 调用nvmsync\+\_\+sync持久化文件
\end{DoxyEnumerate}}}

{\bfseries{{\bfseries{nvmsync\+\_\+sync(void $\ast$addr, size\+\_\+t len, unsigned long new\+\_\+epoch)$\ast$$\ast$将内存映射文件同步回\+PM
\begin{DoxyEnumerate}
\item 根据address映射table。 $\ast$$\ast$radix tree的组织方式
\item 根据len获取到每一个可能需要sync的entry所在的table。
\item 对每一个epoch $<$ new\+\_\+epoch的entry进行同步并flush
\item 释放index\+\_\+entry回local list中
\item 释放local list回global list
\end{DoxyEnumerate}}}}}

{\bfseries{{\bfseries{{\bfseries{nvwrite(fd, buf, cnt)\+:}} 写操作的入口
\begin{DoxyEnumerate}
\item get\+\_\+fd\+\_\+addr\+\_\+cur()获得dst
\item pwrite\+To\+Map(fd, buf, cnt, dst)
\begin{DoxyEnumerate}
\item 获取uma信息
\item 若空间不足，则进行重映射并expand。
\begin{DoxyEnumerate}
\item 扩展\+P\+M空间
\item {\bfseries{S\+Y\+NC}}
\item munmap uma：从rbtree中删除该uma的信息
\item nvmmap
\item 修改fd\+\_\+table中的信息并返回uma
\end{DoxyEnumerate}
\item 写请求次数加一
\item {\bfseries{nvmemcpy\+\_\+write}}
\end{DoxyEnumerate}
\item 更新静态数组fd\+\_\+table中对应的信息，包括offset、written\+\_\+file\+\_\+size等。
\end{DoxyEnumerate}}}}}

{\bfseries{{\bfseries{{\bfseries{nvmemcpy\+\_\+write(dst, buf, cnt, dst\+\_\+uma)：}} 将数据写入到log entry中
\begin{DoxyEnumerate}
\item 对uma上锁
\item 获取\+Index对应的\+Table（从global\+\_\+table\+\_\+list中获取）
\item 根据写入内容的大小设置log\+\_\+size(log\+\_\+entry的大小)
\item 获得entry在table中的索引 $\ast$循环体$\ast$将数据写入多个连续的entry（有可能跨table）
\begin{DoxyEnumerate}
\item 从table中索引对应的index entry（若为\+N\+U\+L\+L，从global\+\_\+entry\+\_\+list中申请，其中包括对log entry的空间申请，从global\+\_\+data\+\_\+list中获取）
\item 对index entry上锁
\item 若是已经commit，则$\ast$$\ast$sync\+\_\+entry$\ast$$\ast$ {\ttfamily 什么情况下会出现这种情况？}
\item 根据log policy执行写入操作 nvmmio\+\_\+write
\item 处理overwrite。这一部分的逻辑主要是将pre\+\_\+log和刚写的log中间的空白进行填充，以保证entry中数据的连续性，并能够通过offset和len记录有效数据。
\item 记录entry中的offset、len和dst。（{\ttfamily }
\item {\ttfamily \`{}通过dst和offset可以获得写回的位置吗？}{\ttfamily ）}
\item {\ttfamily 持久化index entry（}{\ttfamily 这个操作是否有必要？}\`{}）
\end{DoxyEnumerate}
\item 如果是undo log，则就地更新。
\end{DoxyEnumerate}}}}}

{\bfseries{{\bfseries{{\bfseries{sync\+\_\+entry(log\+\_\+entry\+\_\+t $\ast$entry, uma\+\_\+t $\ast$uma)}} 对已提交的log\+\_\+entry进行写回（需上锁）。
\begin{DoxyEnumerate}
\item 根据entry中的dst和offset得出dst，如果是redo log则进行写回，并且更新结构体数据。 
\end{DoxyEnumerate}}}}}